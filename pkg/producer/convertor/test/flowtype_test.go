// Copyright 2020 VMware, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package test

import (
	"net"
	"testing"

	"github.com/Shopify/sarama"
	saramamock "github.com/Shopify/sarama/mocks"
	"github.com/stretchr/testify/assert"

	"github.com/vmware/go-ipfix/pkg/entities"
	"github.com/vmware/go-ipfix/pkg/producer"
	"github.com/vmware/go-ipfix/pkg/producer/convertor"
	"github.com/vmware/go-ipfix/pkg/registry"
)

var (
	// Hard coding the kafka msg in bytes. Need to figure out a way to generate this.
	msg1ForFlowType1 = []byte{0x0, 0x0, 0x0, 0xa7, 0xa, 0xa4, 0x1, 0x10, 0x1, 0x18,
		0xd2, 0x9, 0x32, 0x8, 0x31, 0x30, 0x2e, 0x30, 0x2e, 0x30, 0x2e, 0x31, 0x3a,
		0x8, 0x31, 0x30, 0x2e, 0x30, 0x2e, 0x30, 0x2e, 0x32, 0x40, 0xd2, 0x9, 0x48,
		0xae, 0x2c, 0x50, 0x6, 0x58, 0xe8, 0x7, 0x60, 0xe8, 0x7, 0x68, 0xe8, 0x7,
		0x70, 0xe8, 0x7, 0x78, 0x32, 0x80, 0x1, 0x32, 0x88, 0x1, 0x32, 0x90, 0x1,
		0x32, 0x9a, 0x1, 0x5, 0x4, 0x70, 0x6f, 0x64, 0x31, 0xa2, 0x1, 0x7, 0x6, 0x70,
		0x6f, 0x64, 0x6e, 0x73, 0x31, 0xaa, 0x1, 0x6, 0x5, 0x6e, 0x6f, 0x64, 0x65,
		0x31, 0xb2, 0x1, 0x5, 0x4, 0x70, 0x6f, 0x64, 0x32, 0xba, 0x1, 0x7, 0x6, 0x70,
		0x6f, 0x64, 0x6e, 0x73, 0x32, 0xc2, 0x1, 0x6, 0x5, 0x6e, 0x6f, 0x64, 0x65,
		0x32, 0xca, 0x1, 0xb, 0x31, 0x39, 0x32, 0x2e, 0x31, 0x36, 0x38, 0x2e, 0x30,
		0x2e, 0x31, 0xd2, 0x1, 0x5, 0x4, 0x73, 0x76, 0x63, 0x31, 0xea, 0x1, 0x1,
		0x0, 0xf2, 0x1, 0x1, 0x0, 0xfa, 0x1, 0x1, 0x0, 0x82, 0x2, 0x1, 0x0, 0x8a,
		0x2, 0x9, 0x31, 0x32, 0x37, 0x2e, 0x30, 0x2e, 0x30, 0x2e, 0x31, 0x90, 0x2,
		0x83, 0x25}
	msg2ForFlowType1 = []byte{0x0, 0x0, 0x0, 0xd7, 0xa, 0xd4, 0x1, 0x10, 0x1, 0x18,
		0xd2, 0x9, 0x32, 0x19, 0x32, 0x30, 0x30, 0x31, 0x3a, 0x30, 0x3a, 0x33, 0x32,
		0x33, 0x38, 0x3a, 0x64, 0x66, 0x65, 0x31, 0x3a, 0x36, 0x33, 0x3a, 0x3a,
		0x66, 0x65, 0x66, 0x62, 0x3a, 0x19, 0x32, 0x30, 0x30, 0x31, 0x3a, 0x30,
		0x3a, 0x33, 0x32, 0x33, 0x38, 0x3a, 0x64, 0x66, 0x65, 0x31, 0x3a, 0x36,
		0x33, 0x3a, 0x3a, 0x66, 0x65, 0x66, 0x63, 0x40, 0xd2, 0x9, 0x48, 0xae,
		0x2c, 0x50, 0x6, 0x58, 0xe8, 0x7, 0x60, 0xe8, 0x7, 0x68, 0xe8, 0x7, 0x70,
		0xe8, 0x7, 0x78, 0x32, 0x80, 0x1, 0x32, 0x88, 0x1, 0x32, 0x90, 0x1, 0x32,
		0x9a, 0x1, 0x5, 0x4, 0x70, 0x6f, 0x64, 0x31, 0xa2, 0x1, 0x7, 0x6, 0x70,
		0x6f, 0x64, 0x6e, 0x73, 0x31, 0xaa, 0x1, 0x6, 0x5, 0x6e, 0x6f, 0x64, 0x65,
		0x31, 0xb2, 0x1, 0x5, 0x4, 0x70, 0x6f, 0x64, 0x32, 0xba, 0x1, 0x7, 0x6,
		0x70, 0x6f, 0x64, 0x6e, 0x73, 0x32, 0xc2, 0x1, 0x6, 0x5, 0x6e, 0x6f, 0x64,
		0x65, 0x32, 0xca, 0x1, 0x19, 0x32, 0x30, 0x30, 0x31, 0x3a, 0x30, 0x3a, 0x33,
		0x32, 0x33, 0x38, 0x3a, 0x65, 0x66, 0x65, 0x31, 0x3a, 0x36, 0x33, 0x3a, 0x3a,
		0x66, 0x65, 0x66, 0x65, 0xd2, 0x1, 0x5, 0x4, 0x73, 0x76, 0x63, 0x31, 0xea,
		0x1, 0x1, 0x0, 0xf2, 0x1, 0x1, 0x0, 0xfa, 0x1, 0x1, 0x0, 0x82, 0x2, 0x1,
		0x0, 0x8a, 0x2, 0x9, 0x31, 0x32, 0x37, 0x2e, 0x30, 0x2e, 0x30, 0x2e, 0x31,
		0x90, 0x2, 0x83, 0x25}
	msg1ForFlowType2 = []byte{0x0, 0x0, 0x0, 0xa7, 0x12, 0xa4, 0x1, 0x10, 0x1, 0x18,
		0xd2, 0x9, 0x32, 0x8, 0x31, 0x30, 0x2e, 0x30, 0x2e, 0x30, 0x2e, 0x31, 0x3a,
		0x8, 0x31, 0x30, 0x2e, 0x30, 0x2e, 0x30, 0x2e, 0x32, 0x40, 0xd2, 0x9, 0x48,
		0xae, 0x2c, 0x50, 0x6, 0x58, 0xe8, 0x7, 0x60, 0xe8, 0x7, 0x68, 0xe8, 0x7,
		0x70, 0xe8, 0x7, 0x78, 0x32, 0x80, 0x1, 0x32, 0x88, 0x1, 0x32, 0x90, 0x1,
		0x32, 0x9a, 0x1, 0x5, 0x4, 0x70, 0x6f, 0x64, 0x31, 0xa2, 0x1, 0x7, 0x6,
		0x70, 0x6f, 0x64, 0x6e, 0x73, 0x31, 0xaa, 0x1, 0x6, 0x5, 0x6e, 0x6f, 0x64,
		0x65, 0x31, 0xb2, 0x1, 0x5, 0x4, 0x70, 0x6f, 0x64, 0x32, 0xba, 0x1, 0x7,
		0x6, 0x70, 0x6f, 0x64, 0x6e, 0x73, 0x32, 0xc2, 0x1, 0x6, 0x5, 0x6e, 0x6f,
		0x64, 0x65, 0x32, 0xca, 0x1, 0xb, 0x31, 0x39, 0x32, 0x2e, 0x31, 0x36, 0x38,
		0x2e, 0x30, 0x2e, 0x31, 0xd2, 0x1, 0x5, 0x4, 0x73, 0x76, 0x63, 0x31, 0xea,
		0x1, 0x1, 0x0, 0xf2, 0x1, 0x1, 0x0, 0xfa, 0x1, 0x1, 0x0, 0x82, 0x2, 0x1,
		0x0, 0x8a, 0x2, 0x9, 0x31, 0x32, 0x37, 0x2e, 0x30, 0x2e, 0x30, 0x2e, 0x31,
		0x90, 0x2, 0x83, 0x25}
	msg2ForFlowType2 = []byte{0x0, 0x0, 0x0, 0xd7, 0x12, 0xd4, 0x1, 0x10, 0x1, 0x18,
		0xd2, 0x9, 0x32, 0x19, 0x32, 0x30, 0x30, 0x31, 0x3a, 0x30, 0x3a, 0x33, 0x32,
		0x33, 0x38, 0x3a, 0x64, 0x66, 0x65, 0x31, 0x3a, 0x36, 0x33, 0x3a, 0x3a,
		0x66, 0x65, 0x66, 0x62, 0x3a, 0x19, 0x32, 0x30, 0x30, 0x31, 0x3a, 0x30,
		0x3a, 0x33, 0x32, 0x33, 0x38, 0x3a, 0x64, 0x66, 0x65, 0x31, 0x3a, 0x36,
		0x33, 0x3a, 0x3a, 0x66, 0x65, 0x66, 0x63, 0x40, 0xd2, 0x9, 0x48, 0xae, 0x2c,
		0x50, 0x6, 0x58, 0xe8, 0x7, 0x60, 0xe8, 0x7, 0x68, 0xe8, 0x7, 0x70, 0xe8,
		0x7, 0x78, 0x32, 0x80, 0x1, 0x32, 0x88, 0x1, 0x32, 0x90, 0x1, 0x32, 0x9a,
		0x1, 0x5, 0x4, 0x70, 0x6f, 0x64, 0x31, 0xa2, 0x1, 0x7, 0x6, 0x70, 0x6f,
		0x64, 0x6e, 0x73, 0x31, 0xaa, 0x1, 0x6, 0x5, 0x6e, 0x6f, 0x64, 0x65, 0x31,
		0xb2, 0x1, 0x5, 0x4, 0x70, 0x6f, 0x64, 0x32, 0xba, 0x1, 0x7, 0x6, 0x70, 0x6f,
		0x64, 0x6e, 0x73, 0x32, 0xc2, 0x1, 0x6, 0x5, 0x6e, 0x6f, 0x64, 0x65, 0x32,
		0xca, 0x1, 0x19, 0x32, 0x30, 0x30, 0x31, 0x3a, 0x30, 0x3a, 0x33, 0x32, 0x33,
		0x38, 0x3a, 0x65, 0x66, 0x65, 0x31, 0x3a, 0x36, 0x33, 0x3a, 0x3a, 0x66, 0x65,
		0x66, 0x65, 0xd2, 0x1, 0x5, 0x4, 0x73, 0x76, 0x63, 0x31, 0xea, 0x1, 0x1,
		0x0, 0xf2, 0x1, 0x1, 0x0, 0xfa, 0x1, 0x1, 0x0, 0x82, 0x2, 0x1, 0x0, 0x8a,
		0x2, 0x9, 0x31, 0x32, 0x37, 0x2e, 0x30, 0x2e, 0x30, 0x2e, 0x31, 0x90, 0x2,
		0x83, 0x25}
)

func init() {
	registry.LoadRegistry()
	convertor.ProtoSchemaConvertor = map[string]convertor.RegisterProtoSchema{
		FlowType1: RegisterFlowType1,
		FlowType2: RegisterFlowType2,
	}
}

func createMsgwithDataSet(t *testing.T, isV6 bool) *entities.Message {
	set := entities.NewSet(true)
	_ = set.PrepareSet(entities.Data, 256)
	elements := make([]*entities.InfoElementWithValue, 0)
	ieNamesIANA := []string{
		"flowStartSeconds",
		"flowEndSeconds",
		"sourceTransportPort",
		"destinationTransportPort",
		"protocolIdentifier",
		"packetTotalCount",
		"octetTotalCount",
		"packetDeltaCount",
		"octetDeltaCount",
	}
	ieNamesV4IANA := []string{
		"sourceIPv4Address",
		"destinationIPv4Address",
	}
	ieNamesV6IANA := []string{
		"sourceIPv6Address",
		"destinationIPv6Address",
	}
	ieNamesIANAReverse := []string{
		"reversePacketTotalCount",
		"reverseOctetTotalCount",
		"reversePacketDeltaCount",
		"reverseOctetDeltaCount",
	}
	ieNamesAntrea := []string{
		"sourcePodName",
		"sourcePodNamespace",
		"sourceNodeName",
		"destinationPodName",
		"destinationPodNamespace",
		"destinationNodeName",
		"destinationServicePort",
		"destinationServicePortName",
		"ingressNetworkPolicyName",
		"ingressNetworkPolicyNamespace",
		"egressNetworkPolicyName",
		"egressNetworkPolicyNamespace",
	}
	ieNamesV4Antrea := []string{
		"destinationClusterIPv4",
	}
	ieNamesV6Antrea := []string{
		"destinationClusterIPv6",
	}
	if isV6 {
		ieNamesIANA = append(ieNamesIANA, ieNamesV6IANA...)
		ieNamesAntrea = append(ieNamesAntrea, ieNamesV6Antrea...)
	} else {
		ieNamesIANA = append(ieNamesIANA, ieNamesV4IANA...)
		ieNamesAntrea = append(ieNamesAntrea, ieNamesV4Antrea...)
	}
	for _, ieName := range ieNamesIANA {
		ie, err := registry.GetInfoElement(ieName, registry.IANAEnterpriseID)
		if err != nil {
			t.Fatalf("Error when fetching element with name %v: %v", ieName, err)
		}
		ieWithValue := entities.NewInfoElementWithValue(ie, nil)
		var value []byte
		switch ieName {
		case "flowStartSeconds", "flowEndSeconds":
			// hardcoding it to initial epoch to make the test simple.
			value, _ = entities.EncodeToIEDataType(entities.DateTimeSeconds, uint32(0))
		case "sourceIPv4Address":
			value, _ = entities.EncodeToIEDataType(entities.Ipv4Address, net.IP{10, 0, 0, 1})
		case "sourceIPv6Address":
			value, _ = entities.EncodeToIEDataType(entities.Ipv6Address, net.ParseIP("2001:0:3238:DFE1:63::FEFB"))
		case "destinationIPv4Address":
			value, _ = entities.EncodeToIEDataType(entities.Ipv4Address, net.IP{10, 0, 0, 2})
		case "destinationIPv6Address":
			value, _ = entities.EncodeToIEDataType(entities.Ipv6Address, net.ParseIP("2001:0:3238:DFE1:63::FEFC"))
		case "sourceTransportPort":
			value, _ = entities.EncodeToIEDataType(entities.Unsigned16, uint16(1234))
		case "destinationTransportPort":
			value, _ = entities.EncodeToIEDataType(entities.Unsigned16, uint16(5678))
		case "protocolIdentifier":
			value, _ = entities.EncodeToIEDataType(entities.Unsigned8, uint8(6))
		case "packetTotalCount", "octetTotalCount", "packetDeltaCount", "octetDeltaCount":
			value, _ = entities.EncodeToIEDataType(entities.Unsigned64, uint64(1000))
		default:
			t.Fatalf("information element with name: %v is not present in the element list", ieName)
		}
		ieWithValue.Value = value
		elements = append(elements, ieWithValue)
	}

	for _, ieName := range ieNamesIANAReverse {
		ie, err := registry.GetInfoElement(ieName, registry.IANAReversedEnterpriseID)
		if err != nil {
			t.Fatalf("Error when fetching element with name %v: %v", ieName, err)
		}
		ieWithValue := entities.NewInfoElementWithValue(ie, nil)
		var value []byte
		switch ieName {
		case "reversePacketTotalCount", "reverseOctetTotalCount", "reversePacketDeltaCount", "reverseOctetDeltaCount":
			value, _ = entities.EncodeToIEDataType(entities.Unsigned64, uint64(50))
		default:
			t.Fatalf("information element with name: %v is not present in the element list", ieName)
		}
		ieWithValue.Value = value
		elements = append(elements, ieWithValue)
	}

	for _, ieName := range ieNamesAntrea {
		ie, err := registry.GetInfoElement(ieName, registry.AntreaEnterpriseID)
		if err != nil {
			t.Fatalf("Error when fetching element with name %v: %v", ieName, err)
		}
		ieWithValue := entities.NewInfoElementWithValue(ie, nil)
		var value []byte
		switch ieName {
		case "sourcePodNamespace":
			value, _ = entities.EncodeToIEDataType(entities.String, "podns1")
		case "sourcePodName":
			value, _ = entities.EncodeToIEDataType(entities.String, "pod1")
		case "sourceNodeName":
			value, _ = entities.EncodeToIEDataType(entities.String, "node1")
		case "destinationPodNamespace":
			value, _ = entities.EncodeToIEDataType(entities.String, "podns2")
		case "destinationPodName":
			value, _ = entities.EncodeToIEDataType(entities.String, "pod2")
		case "destinationNodeName":
			value, _ = entities.EncodeToIEDataType(entities.String, "node2")
		case "destinationClusterIPv4":
			value, _ = entities.EncodeToIEDataType(entities.Ipv4Address, net.IP{192, 168, 0, 1})
		case "destinationClusterIPv6":
			value, _ = entities.EncodeToIEDataType(entities.Ipv6Address, net.ParseIP("2001:0:3238:EFE1:63::FEFE"))
		case "destinationServicePort":
			value, _ = entities.EncodeToIEDataType(entities.Unsigned16, uint16(4739))
		case "destinationServicePortName":
			value, _ = entities.EncodeToIEDataType(entities.String, "svc1")
		case "ingressNetworkPolicyName", "ingressNetworkPolicyNamespace", "egressNetworkPolicyName", "egressNetworkPolicyNamespace":
			value, _ = entities.EncodeToIEDataType(entities.String, "")
		default:
			t.Fatalf("information element with name: %v is not present in the element list", ieName)
		}
		ieWithValue.Value = value
		elements = append(elements, ieWithValue)
	}
	if err := set.AddRecord(elements, 256); err != nil {
		t.Fatal("Error when adding elements to the record")
	}
	msg := entities.NewMessage(true)
	msg.SetVersion(10)
	msg.SetObsDomainID(uint32(1234))
	msg.SetSequenceNum(1)
	msg.SetMessageLen(32)
	msg.SetExportAddress("127.0.0.1")
	msg.AddSet(set)

	return msg
}

func TestKafkaProducer_Publish(t *testing.T) {
	kafkaConfig := sarama.NewConfig()
	kafkaConfig.Version = sarama.DefaultVersion
	kafkaConfig.Producer.Return.Successes = true
	kafkaConfig.Producer.Return.Errors = true

	testInput := producer.ProducerInput{
		KafkaLogSuccesses: false,
		KafkaTopic:        "test-flow-msgs",
	}

	tests := []struct {
		name         string
		protoSchema  string
		expectedMsg1 []byte
		expectedMsg2 []byte
	}{
		{
			"test-with-FlowType1",
			FlowType1,
			msg1ForFlowType1,
			msg2ForFlowType1,
		},
		{
			"test-with-FlowType2",
			FlowType2,
			msg1ForFlowType2,
			msg2ForFlowType2,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mockSaramaProducer := saramamock.NewAsyncProducer(t, kafkaConfig)
			testInput.KafkaProtoSchema = tt.protoSchema
			kafkaProducer := producer.NewKafkaProducer(testInput)
			kafkaProducer.SetSaramaProducer(mockSaramaProducer)

			mockSaramaProducer.ExpectInputAndSucceed()
			mockSaramaProducer.ExpectInputAndSucceed()
			messageChan := make(chan *entities.Message)
			go func() {
				messageChan <- createMsgwithDataSet(t, false)
				messageChan <- createMsgwithDataSet(t, true)
				close(messageChan)
			}()

			kafkaProducer.Publish(messageChan)

			kafkaMsg1 := <-mockSaramaProducer.Successes()
			kafkaMsg1InBytes, _ := kafkaMsg1.Value.Encode()
			assert.Equalf(t, tt.expectedMsg1, kafkaMsg1InBytes, "kafka msg should be equal to expected bytes")
			kafkaMsg2 := <-mockSaramaProducer.Successes()
			kafkaMsg2InBytes, _ := kafkaMsg2.Value.Encode()
			assert.Equalf(t, tt.expectedMsg2, kafkaMsg2InBytes, "kafka msg should be equal to expected bytes")

			if err := mockSaramaProducer.Close(); err != nil {
				t.Fatal(err)
			}
		})
	}
}
